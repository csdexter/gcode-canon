* we are not a G-Code validator, input must be well formed. We will fathom the 
  widest possible extent of G-Code in use in the wild, but we will neither
  check nor fix your spelling.
* machine coordinate system is in mm
* only three axes (no A,B,C)
* arc I,J,K are *always* relative to the arc starting point
* machine display/conceptual precision is 10um
* integers must be integers, no G00.0000000 garbage.
* surprisingly, gcode-machine should poll overrides and dynamically apply any
  changes.
* the initial G-Code parser blueprint looked like this: {
/**
 * - echo (MSG, [already done first by input]
 * - if(seen_G && arg = have_G(2, 93, 94)) state.feedrateMode = arg
 * - if(seen_F) state.feedrate = get_override_feed_machine(get_F()) [returns 100% if disabled]
 * - if(seen_S) state.spindleSpeed = get_override_speed_machine(get_S()), set_spindle_speed_machine(state.spindleSpeed)
 * - if(seen_T) state.tool = get_T(), preselect_tool_machine(state.tool) [moves carousel]
 * - if(seen_M && have_M(1, 6)) change_tool_machine(state.tool) [actually changes tool]
 * - if(seen_M && have_M(1, 52)) change_tool_machine(TOOL_EMPTY) [unload spindle]
 * - if(seen_M && arg = have_M(2, 26, 27)) select_probe_machine(arg)
 * - if(seen_M && arg = have_M(2, 41, 42)) set_probemode_machine(arg)
 * - if(seen_M && arg = have_M(3, 3, 4, 5)) start_spindle_machine(arg)
 * - if(seen_M && arg = have_M(5, 7, 8, 9, 68, 69)) start_coolant_machine(arg)
 * - if(seen_M && arg = have_M(2, 13, 14)) start_spindle_and_coolant_machine(arg))
 * - if(seen_M && arg = have_M(2, 48, 49)) enable_override_machine(arg)
 * - if(seen_G && have_G(1, 4)) dwell_machine(get_P())
 * - if(seen_G && arg = have_G(3, 17, 18, 19)) state.systemPlane = arg
 * - if(seen_G && arg = have_G(2, 20, 21)) state.systemUnits = arg
 * - if(seen_G && arg = have_G(3, 40, 41, 42)) state.systemRadComp = arg
 * - if(seen_G && arg = have_G(3, 43, 44, 49)) state.systemLenComp = arg
 * - if(seen_G && arg = have_G(6, 53, 54, 55, 56, 57, 58, 59)) state.systemCurrent = arg
 * - if(seen_M && arg = have_M(3, 21, 22, 23)) enable_mirror_machine(arg)
 * - if(seen_G && arg = have_G(2, 22, 23)) state.systemMirror = (arg, get_X(), get_Y(), get_Z())
 * - if(seen_G && arg = have_G(2, 68, 69)) state.systemRotation = (arg, get_X(), get_Y(), get_R())
 * - if(seen_G && arg = have_G(2, 61, 64)) set_pathcontrol_machine(arg)
 * - if(seen_G && have_G(1, 9)) nmPC = true, oldPC = get_pathcontrol_machine(), set_pathcontrol_machine(EXACT)
 * - if(seen_G && arg = have_G(2, 90, 91)) state.systemAbsolute = arg
 * - if(seen_G && arg = have_G(2, 15, 16)) state.systemCartesian = arg
 * - if(seen_G && arg = have_G(2, 50, 51)) state.systemScaling = (arg, get_I(), get_J(), get_K(), get_P())
 * - if(seen_G && arg = have_G(2, 98, 99)) state.retractMode = arg
 * - if(seen_G)
 *     if(arg = have_G(4, 28, 29, 30, 80))
 *       state.motionMode = OFF
 *       if(arg != 80) move_machine_home(arg, get_X(), get_Y(), get_Z())
 *     if(arg = have_G(2, 10, 11)) oldMode = state.motionMode, state.motionMode = store_parameter_mode(arg) [which means STORE or oldMode]
 *     if(have_G(1, 92)) state.systemOffset = (get_X(), get_Y(), get_Z())
 * - if(seen_G)
 *     if(arg = have_G(6, 0, 1, 2, 3, 12, 13)) state.motionMode = arg
 *     if(arg = have_G(13, 31, 38, 73, 74, 81, 82, 83, 84, 85, 86, 87, 88, 89)) state.motionMode = CYCLE, state.cycle = arg
 * - if(seen_M && arg = have_M(3, 19, 20, 25)) move_machine_aux(arg)
 * - switch(state.motionMode)
 *     RAPID, LINEAR: move_machine_line(do_WCS_math(get_X(), get_Y(), get_Z(), state.system*), state.feedrate, state.feedrateMode)
 *     ARC, CIRCLE: move_machine_arc(do_WCS_math(get_X(), get_Y(), get_Z(), state.system*), get_I(), get_J(), get_K(), get_R(), get_P(), state.feedrate, state.feedrateMode)
 *     STORE: do_data_input(get_L(), get_P(), ...), commit_data()
 *     CYCLE: move_machine_cycle(state.cycle, do_WCS_math(get_X(), get_Y(), get_Z(), state.system*), state.retractMode, get_L(), get_P(), get_Q(), get_R(), state.feedrate, state.feedrateMode)
 *     OFF: <NOP>
 * - if(nmPC && state.motionMode != OFF) set_pathcontrol_machine(oldPC), nmPC = false
 * - if(seen_G && have_G(1, 65)) cmsc = true, push_parameters(), update_parameters(map_words_to_parameters(get_ALL()))
 * - if(seen_M && arg = have_M(8, 0, 1, 2, 17, 18, 30, 36, 60)) stop_machine(arg) [which reads Optional Stop and/or terminates us accordingly]
 * - update_parameters(parse_parameters(line)) [takes care of assignments #<idx>=<value OR #<param>>]
 * - commit_parameters() [always last on the line, according to the standard]
 * - if(seen_M) [since these change the line, they're conceptually after the end]
 *     if(have_M(1, 47)) rewind_input()
 *     if(have_M(1, 98)) push(tell_input()), seek_line_input(programs[get_P()]), push(tell_input()), repeat = get_L()
 *     if(have_M(1, 99))
 *       if(repeat) repeat--, seek_line_input(peek())
 *       if(!repeat) pop(), seek_line_input(pop())
 *         if(cmsc) cmsc = false, pop_parameters() [pop_parameters() calls commit internally]
 */
}
* initial per-axis movement queue records looked like this {
  typedef enum {
    AXIS_NOP,
    AXIS_LINEAR,
    AXIS_CIRCULAR_X,
    AXIS_CIRCULAR_Y
  } TGCodeAxisMovementSpec;
  
  typedef struct {
    TGCodeAxisMovementSpec movementType;
    bool isPositive; /* false for towards zero or CCW, true for away from zero or CW */
    uint32_t targetSpeed; /* in steps/sec or Bresenham iterations/sec */
    uint32_t stepsToGo; /* in steps */
    uint32_t radius; /* in steps */
    int32_t initialError; /* in steps */
    // TODO: find minimum set of data needed for arcs and put it here
  } TGCodeAxisSpec;
}